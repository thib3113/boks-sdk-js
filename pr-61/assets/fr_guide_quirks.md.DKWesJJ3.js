import{_ as r,o as a,c as s,a1 as o}from"./chunks/framework.kgMnPKSd.js";const m=JSON.parse('{"title":"Bugs & Particularités du Protocole (Quirks)","description":"","frontmatter":{},"headers":[],"relativePath":"fr/guide/quirks.md","filePath":"fr/guide/quirks.md"}'),t={name:"fr/guide/quirks.md"};function i(n,e,l,u,d,c){return a(),s("div",null,[...e[0]||(e[0]=[o('<h1 id="bugs-particularites-du-protocole-quirks" tabindex="-1">Bugs &amp; Particularités du Protocole (Quirks) <a class="header-anchor" href="#bugs-particularites-du-protocole-quirks" aria-label="Permalink to &quot;Bugs &amp; Particularités du Protocole (Quirks)&quot;">​</a></h1><p>La rétro-ingénierie de matériel réel révèle souvent des comportements non documentés ou des bugs. Cette page recense les particularités connues du firmware Boks que les développeurs doivent prendre en compte.</p><h2 id="_1-suppression-des-codes-a-usage-unique-opcode-0x0d" tabindex="-1">1. Suppression des codes à usage unique (Opcode 0x0D) <a class="header-anchor" href="#_1-suppression-des-codes-a-usage-unique-opcode-0x0d" aria-label="Permalink to &quot;1. Suppression des codes à usage unique (Opcode 0x0D)&quot;">​</a></h2><p>Lors de l&#39;envoi d&#39;une commande pour supprimer un code à usage unique via Bluetooth (Opcode <code>0x0D</code>), le comportement du matériel est incohérent avec le reste du protocole.</p><ul><li><strong>La Particularité</strong> : Même si le code est <strong>correctement supprimé</strong> de la mémoire interne de l&#39;appareil, le firmware retourne une erreur <code>CODE_OPERATION_ERROR</code> (<code>0x78</code>) au lieu d&#39;une notification de succès.</li></ul><h2 id="_2-encodage-et-transmission-de-la-configkey" tabindex="-1">2. Encodage et Transmission de la ConfigKey <a class="header-anchor" href="#_2-encodage-et-transmission-de-la-configkey" aria-label="Permalink to &quot;2. Encodage et Transmission de la ConfigKey&quot;">​</a></h2><p>Le mécanisme d&#39;authentification par <strong>ConfigKey</strong> utilise un format spécifique qui diffère des protocoles binaires standards.</p><ul><li><strong>Transmission ASCII</strong> : Bien que la ConfigKey soit une représentation hexadécimale de 4 octets, elle est <strong>toujours transmise sous la forme d&#39;une chaîne ASCII de 8 caractères</strong> dans la charge utile des paquets authentifiés. C&#39;est moins efficace que l&#39;envoi des 4 octets bruts, mais c&#39;est une exigence stricte de l&#39;analyseur (parser) du firmware.</li><li><strong>Ordre des octets (Endianness)</strong> : Le firmware attend que la chaîne hexadécimale de 8 caractères soit transmise en <strong>hex ASCII Little Endian</strong>, puis la réordonne en interne avant la comparaison.</li><li><strong>Exemple</strong> : Si votre clé est <code>AABBCCDD</code>, elle doit être envoyée sous la forme <code>DDCCBBAA</code> selon l&#39;opcode et la version du firmware.</li></ul><h2 id="_3-volatilite-de-la-master-key-masquage-flash" tabindex="-1">3. Volatilité de la Master Key (Masquage Flash) <a class="header-anchor" href="#_3-volatilite-de-la-master-key-masquage-flash" aria-label="Permalink to &quot;3. Volatilité de la Master Key (Masquage Flash)&quot;">​</a></h2><p>Le matériel Boks ne stocke pas la <strong>Master Key</strong> complète de 32 octets dans sa mémoire flash à long terme.</p><ul><li><strong>La Particularité</strong> : Lorsqu&#39;une Master Key est fournie (via le provisioning ou la régénération), le matériel utilise la clé complète pour dériver le pool initial de codes. Cependant, avant de persister la clé dans le Flash Data Storage (FDS), il <strong>met à zéro plusieurs octets</strong> (généralement les 8 premiers octets).</li><li><strong>Conséquence</strong> : Cela signifie que le matériel ne peut pas &quot;régénérer&quot; son propre pool de codes à partir de son stockage interne s&#39;ils sont perdus ; la clé complète doit être fournie à nouveau par le client pour toute opération de régénération.</li></ul><h2 id="_4-precision-de-l-age-dans-l-historique" tabindex="-1">4. Précision de l&#39;âge dans l&#39;historique <a class="header-anchor" href="#_4-precision-de-l-age-dans-l-historique" aria-label="Permalink to &quot;4. Précision de l&#39;âge dans l&#39;historique&quot;">​</a></h2><p>Le champ d&#39;âge sur 3 octets dans les événements d&#39;historique (flux <code>0x03</code>) est calculé par le firmware par rapport à son temps de fonctionnement interne (uptime).</p><ul><li><strong>La Particularité</strong> : Si l&#39;appareil redémarre, l&#39;uptime est réinitialisé. L&#39;âge rapporté pour les événements antérieurs au redémarrage peut être calculé de manière erronée si l&#39;horloge RTC (Real Time Clock) n&#39;a pas été synchronisée.</li><li><strong>Conséquence</strong> : La date absolue doit être calculée en soustrayant l&#39;âge de l&#39;heure locale actuelle au moment de la réception.</li></ul><h2 id="_5-generation-de-codes-multi-usages" tabindex="-1">5. Génération de Codes Multi-Usages <a class="header-anchor" href="#_5-generation-de-codes-multi-usages" aria-label="Permalink to &quot;5. Génération de Codes Multi-Usages&quot;">​</a></h2><p>Comme indiqué dans le <a href="./protocol.html">Guide du Protocole</a>, les versions de firmware strictement supérieures à <strong>4.3.3</strong> ont désactivé la génération de nouveaux codes Multi-Usages.</p><ul><li><strong>La Particularité</strong> : Envoyer un <code>CREATE_MULTI_USE_CODE</code> (<code>0x13</code>) sur ces versions retournera une erreur, même si la charge utile et l&#39;authentification sont correctes.</li></ul>',17)])])}const g=r(t,[["render",i]]);export{m as __pageData,g as default};
