import{_ as t,o,c as i,a1 as r}from"./chunks/framework.CwKp01OX.js";const g=JSON.parse('{"title":"Known Bugs & Protocol Quirks","description":"","frontmatter":{},"headers":[],"relativePath":"guide/quirks.md","filePath":"guide/quirks.md"}'),s={name:"guide/quirks.md"};function a(n,e,l,d,c,h){return o(),i("div",null,[...e[0]||(e[0]=[r('<h1 id="known-bugs-protocol-quirks" tabindex="-1">Known Bugs &amp; Protocol Quirks <a class="header-anchor" href="#known-bugs-protocol-quirks" aria-label="Permalink to &quot;Known Bugs &amp; Protocol Quirks&quot;">​</a></h1><p>Reverse engineering real hardware often reveals undocumented behaviors or bugs. This page lists the known quirks of the Boks firmware that developers should be aware of when implementing custom clients.</p><h2 id="_1-deleting-single-use-codes-opcode-0x0d" tabindex="-1">1. Deleting Single-Use Codes (Opcode 0x0D) <a class="header-anchor" href="#_1-deleting-single-use-codes-opcode-0x0d" aria-label="Permalink to &quot;1. Deleting Single-Use Codes (Opcode 0x0D)&quot;">​</a></h2><p>When sending a command to delete a single-use code via Bluetooth (Opcode <code>0x0D</code>), the hardware behavior is inconsistent with the rest of the protocol.</p><ul><li><strong>The Quirk</strong>: Even if the code is <strong>successfully deleted</strong> from the device&#39;s internal storage, the firmware returns a <code>CODE_OPERATION_ERROR</code> (<code>0x78</code>) instead of a success notification.</li></ul><h2 id="_2-configkey-encoding-transmission" tabindex="-1">2. ConfigKey Encoding &amp; Transmission <a class="header-anchor" href="#_2-configkey-encoding-transmission" aria-label="Permalink to &quot;2. ConfigKey Encoding &amp; Transmission&quot;">​</a></h2><p>The <strong>ConfigKey</strong> authentication mechanism uses a specific format that differs from standard binary protocols.</p><ul><li><strong>ASCII Transmission</strong>: Although the ConfigKey is a hexadecimal representation of 4 bytes, it is <strong>always transmitted as an 8-character ASCII string</strong> in the payload of authenticated packets. This is less efficient than sending the raw 4 bytes but is strictly required by the firmware parser.</li><li><strong>Byte Order (Endianness)</strong>: The firmware expects the 8-character hex string to be transmitted in <strong>Little Endian hex ASCII</strong>, but then re-sequences it internally before comparison.</li><li><strong>Example</strong>: If your key is <code>AABBCCDD</code>, it might need to be sent as <code>DDCCBBAA</code> depending on the opcode and firmware version.</li></ul><h2 id="_3-master-key-volatility-flash-masking" tabindex="-1">3. Master Key Volatility (Flash Masking) <a class="header-anchor" href="#_3-master-key-volatility-flash-masking" aria-label="Permalink to &quot;3. Master Key Volatility (Flash Masking)&quot;">​</a></h2><p>The Boks hardware does not store the complete 32-byte <strong>Master Key</strong> in its long-term flash memory.</p><ul><li><strong>The Quirk</strong>: When a Master Key is provided (via provisioning or regeneration), the hardware uses the full key to derive the initial pool of codes. However, before persisting the key to the Flash Data Storage (FDS), it <strong>zeroes out several bytes</strong> (usually the first 8 bytes).</li><li><strong>Consequence</strong>: This means the hardware cannot &quot;re-generate&quot; its own codes pool from its internal storage if they are lost; the full key must be provided again by the client for any regeneration operation.</li></ul><h2 id="_4-history-age-precision" tabindex="-1">4. History Age Precision <a class="header-anchor" href="#_4-history-age-precision" aria-label="Permalink to &quot;4. History Age Precision&quot;">​</a></h2><p>The 3-byte age field in history events (<code>0x03</code> burst) is calculated by the firmware relative to its internal uptime.</p><ul><li><strong>The Quirk</strong>: If the device reboots, the uptime is reset. The age reported for events prior to the reboot might be calculated incorrectly or based on a legacy timestamp if the RTC (Real Time Clock) was not synchronized.</li><li><strong>Consequence</strong>: The absolute date must be calculated by subtracting the age from the current time at the moment of reception.</li></ul><h2 id="_5-multi-use-code-generation" tabindex="-1">5. Multi-Use Code Generation <a class="header-anchor" href="#_5-multi-use-code-generation" aria-label="Permalink to &quot;5. Multi-Use Code Generation&quot;">​</a></h2><p>As noted in the <a href="./protocol.html">Protocol Guide</a>, firmware versions strictly greater than <strong>4.3.3</strong> have disabled the generation of new Multi-Use codes.</p><ul><li><strong>The Quirk</strong>: Sending a <code>CREATE_MULTI_USE_CODE</code> (<code>0x13</code>) on these versions will return an error, even if the payload and authentication are correct.</li></ul>',17)])])}const m=t(s,[["render",a]]);export{g as __pageData,m as default};
