import{_ as a,o as t,c as r,a1 as i}from"./chunks/framework.BK-XV1bZ.js";const m=JSON.parse('{"title":"Algorithme de Génération de PIN","description":"","frontmatter":{},"headers":[],"relativePath":"fr/guide/pin-algorithm.md","filePath":"fr/guide/pin-algorithm.md"}'),o={name:"fr/guide/pin-algorithm.md"};function s(n,e,l,d,u,c){return t(),r("div",null,[...e[0]||(e[0]=[i('<h1 id="algorithme-de-generation-de-pin" tabindex="-1">Algorithme de Génération de PIN <a class="header-anchor" href="#algorithme-de-generation-de-pin" aria-label="Permalink to &quot;Algorithme de Génération de PIN&quot;">​</a></h1><p>L&#39;écosystème Boks utilise un algorithme de dérivation personnalisé pour générer des codes PIN alphanumériques de 6 caractères à partir d&#39;une <strong>Master Key</strong> de 32 octets. Cela permet au serveur, au smartphone et au matériel de rester synchronisés sans jamais échanger les codes PIN réels sur les ondes.</p><h2 id="apercu-theorique" tabindex="-1">Aperçu Théorique <a class="header-anchor" href="#apercu-theorique" aria-label="Permalink to &quot;Aperçu Théorique&quot;">​</a></h2><p>L&#39;algorithme est basé sur un hash <strong>SHA-256</strong> modifié (ou BLAKE2s dans certaines implémentations) avec un vecteur d&#39;initialisation personnalisé et un mappage final des caractères.</p><h3 id="_1-initialisation-du-hash" tabindex="-1">1. Initialisation du Hash <a class="header-anchor" href="#_1-initialisation-du-hash" aria-label="Permalink to &quot;1. Initialisation du Hash&quot;">​</a></h3><p>Au lieu de l&#39;IV SHA-256 standard, l&#39;algorithme utilise une constante spécifique pour XORer l&#39;état initial :</p><ul><li><strong>Modificateur</strong> : <code>0x01012006</code></li></ul><h3 id="_2-format-du-message" tabindex="-1">2. Format du Message <a class="header-anchor" href="#_2-format-du-message" aria-label="Permalink to &quot;2. Format du Message&quot;">​</a></h3><p>Le message haché dépend du type de code et de son index :</p><ul><li><strong>Format</strong> : <code>&quot;{type} {index}&quot;</code></li><li><strong>Exemple</strong> : <code>&quot;single-use 42&quot;</code> ou <code>&quot;master 0&quot;</code></li></ul><h3 id="_3-mappage-des-caracteres" tabindex="-1">3. Mappage des Caractères <a class="header-anchor" href="#_3-mappage-des-caracteres" aria-label="Permalink to &quot;3. Mappage des Caractères&quot;">​</a></h3><p>Le hash résultant n&#39;est pas utilisé directement. Les 6 premiers octets sont extraits et mappés vers un jeu de 12 caractères :</p><p><strong>Charset</strong> : <code>0 1 2 3 4 5 6 7 8 9 A B</code></p><p>Chaque octet est converti en un index via un modulo 12 : <code>char = Charset[octet % 12]</code></p><h2 id="details-d-implementation" tabindex="-1">Détails d&#39;Implémentation <a class="header-anchor" href="#details-d-implementation" aria-label="Permalink to &quot;Détails d&#39;Implémentation&quot;">​</a></h2><p>Le SDK fournit une implémentation haute performance de cet algorithme dans <code>src/crypto/pin-algorithm.ts</code>. Elle utilise des tampons partagés pour minimiser les allocations mémoire, ce qui la rend adaptée aux appareils basse consommation ou à une génération haute fréquence (ex: générer les 3000 codes dans le simulateur).</p><h2 id="pourquoi-cet-algorithme" tabindex="-1">Pourquoi cet algorithme ? <a class="header-anchor" href="#pourquoi-cet-algorithme" aria-label="Permalink to &quot;Pourquoi cet algorithme ?&quot;">​</a></h2><ul><li><strong>Sync Hors-ligne</strong> : Un appareil Boks n&#39;a pas besoin de Wi-Fi pour savoir si un code est valide.</li><li><strong>Sécurité</strong> : Connaître un PIN ne permet pas de découvrir la Master Key.</li><li><strong>Déterminisme</strong> : Le même tuple (Clé, Type, Index) produira toujours le même PIN.</li></ul>',18)])])}const h=a(o,[["render",s]]);export{m as __pageData,h as default};
