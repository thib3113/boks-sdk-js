import{_ as a,o as t,c as i,a1 as o}from"./chunks/framework.DxRs1__z.js";const g=JSON.parse('{"title":"PIN Generation Algorithm","description":"","frontmatter":{},"headers":[],"relativePath":"guide/pin-algorithm.md","filePath":"guide/pin-algorithm.md"}'),r={name:"guide/pin-algorithm.md"};function n(s,e,h,l,d,c){return t(),i("div",null,[...e[0]||(e[0]=[o('<h1 id="pin-generation-algorithm" tabindex="-1">PIN Generation Algorithm <a class="header-anchor" href="#pin-generation-algorithm" aria-label="Permalink to &quot;PIN Generation Algorithm&quot;">​</a></h1><p>The Boks ecosystem uses a custom derivation algorithm to generate 6-character alphanumeric PIN codes from a 32-byte <strong>Master Key</strong>. This allows the server, the smartphone, and the hardware to stay synchronized without exchanging actual PINs over the air.</p><h2 id="theoretical-overview" tabindex="-1">Theoretical Overview <a class="header-anchor" href="#theoretical-overview" aria-label="Permalink to &quot;Theoretical Overview&quot;">​</a></h2><p>The algorithm is based on a modified <strong>SHA-256</strong> hash (or BLAKE2s in some implementations) with a custom initialization vector and a final character mapping.</p><h3 id="_1-hash-initialization" tabindex="-1">1. Hash Initialization <a class="header-anchor" href="#_1-hash-initialization" aria-label="Permalink to &quot;1. Hash Initialization&quot;">​</a></h3><p>Instead of the standard SHA-256 IV, the algorithm uses a specific constant for XORing the initial state:</p><ul><li><strong>Modifier</strong>: <code>0x01012006</code></li></ul><h3 id="_2-message-format" tabindex="-1">2. Message Format <a class="header-anchor" href="#_2-message-format" aria-label="Permalink to &quot;2. Message Format&quot;">​</a></h3><p>The message hashed depends on the type of code and its index:</p><ul><li><strong>Format</strong>: <code>&quot;{type} {index}&quot;</code></li><li><strong>Example</strong>: <code>&quot;single-use 42&quot;</code> or <code>&quot;master 0&quot;</code></li></ul><h3 id="_3-character-mapping" tabindex="-1">3. Character Mapping <a class="header-anchor" href="#_3-character-mapping" aria-label="Permalink to &quot;3. Character Mapping&quot;">​</a></h3><p>The resulting hash is not used directly. The first 6 bytes are extracted and mapped to a 12-character charset:</p><p><strong>Charset</strong>: <code>0 1 2 3 4 5 6 7 8 9 A B</code></p><p>Each byte is converted to an index using modulo 12: <code>char = Charset[byte % 12]</code></p><h2 id="implementation-details" tabindex="-1">Implementation Details <a class="header-anchor" href="#implementation-details" aria-label="Permalink to &quot;Implementation Details&quot;">​</a></h2><p>The SDK provides a high-performance implementation of this algorithm in <code>src/crypto/pin-algorithm.ts</code>. It uses shared buffers to minimize memory allocations, making it suitable for low-power devices or high-frequency generation (e.g., generating all 3000 codes in the simulator).</p><h2 id="why-this-algorithm" tabindex="-1">Why this algorithm? <a class="header-anchor" href="#why-this-algorithm" aria-label="Permalink to &quot;Why this algorithm?&quot;">​</a></h2><ul><li><strong>Offline Sync</strong>: A Boks device doesn&#39;t need Wi-Fi to know if a code is valid.</li><li><strong>Security</strong>: Knowing a PIN doesn&#39;t reveal the Master Key.</li><li><strong>Determinism</strong>: The same (Key, Type, Index) tuple always produces the same PIN.</li></ul>',18)])])}const p=a(r,[["render",n]]);export{g as __pageData,p as default};
